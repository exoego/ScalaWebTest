---
pageTitle: ScalaWebTest Documentation
title: Documentation
description: A comprehensive guide to writing integration tests with ScalaWebTest
twitterAuthor: danireych
---
<!DOCTYPE HTML>
<html lang="en">

{% include head.ext %}
<body>
{% include header.ext %}
<!-- Main -->
<div id="main">

    <div class="container">
        <div class="row">
            <div id="content">
                <section>
                    <header>
                        <h2 id="coreFeatures">Core Features</h2>
                    </header>
                    <p>ScalaWebTest has two main features.</p>
                    <ul>
                        <li>Handling of web requests and state</li>
                        <li>Gauges for simple tests</li>
                    </ul>
                    <p>The short description of the two main features is followed by a getting started section suitable
                        for beginners and a detailed description of all features.</p>

                    <h3 id="handlingWebRequests">Handling of web requests and state</h3>
                    <p>ScalaWebTest's <a href="#api_IntegrationSpec">IntegrationSpec</a> trait helps you to structure
                        your tests and keep them boilerplate free. It extends the most important traits, to write
                        integration tests for web applications, from ScalaTest.
                        It provides an easy way to configure the Selenium webdriver and it takes care of login, web
                        requests and cookies.
                        Before executing your tests, it takes care of login, if needed. Next it requests the resource,
                        which your test wants to verify. The URL to the tested resource is split in two segments.
                        The <b>baseUri</b> is part of the Configuration, use <b>config.useBaseUri</b> to change it. The
                        <b>path</b>, which is usually different for every test, is then appended to the
                        <code>baseUri</code>.
                        In most cases a test should only work with a single resource, in this case the path doesn't
                        change throughout the test.
                        Per default the IntegrationSpec will, before each test, take care that the current resource in
                        the WebDriver is the one belonging to the defined path. This behavior can be changed.
                        Therefore your test does not have to interact with the WebDriver. Instead it can directly verify
                        the content of the current resource via webdriver.</p>

                    <h3 id="gaugesForSimpleTests">Gauges for simple tests</h3>
                    <p>Selenium is a powerful tool, but testing the returned HTML from a web application is cumbersome
                        and the resulting tests are often hard to read.
                        We think the easiest way to define the expected result of a web request is using the returned
                        data format itself.
                        Therefore we use pseudo HTML (<a href="documentation.html#modules/json/gauge">alternatively JSON
                            to verify JSON</a>)
                        to describe the expected result. Of course a simple string comparison would be to naive.
                        Therefore we treat the HTML (Scala XML literal, to be precise), which is used to describe the
                        expected result,
                        as <a href="#gaugesForSimpleTests">gauge definition</a> (other would call it a template). If all
                        elements from the gauge definition are present in the verified HTML page, it does fit the <b>gauge</b>
                        and is therefore valid.</p>
                </section>
                <section>
                    <header>
                        <h2 id="gettingStarted">Getting started</h2>
                    </header>

                    <h3 id="addSWT">Add ScalaWebTest to your project</h3>
                    <p>Before you get to use all the nice features, you have to introduce ScalaWebTest to your project.
                        All you have to do is adding the core module to your test or integration test dependencies.</p>

                    <h4 id="swt_sbt">Add ScalaWebTest to your SBT project</h4>
                    <p>You can add ScalaWebTest to your testing dependencies in the build.sbt/scala
                        of your sbt project as follows.</p>
                     {% code scala %}
libraryDependencies += "org.scalawebtest" %% "scalawebtest-core" % "{{page.scalaWebTestVersion}}" % "test" {% endcode %}
                    <p>We recommend to bind the ScalaWebTest dependencies to the IntegrationTest configuration, which can be referenced with "it".
                    The IntegrationTest configuration is not active by default. Follow the guide for <a href="https://www.scala-sbt.org/1.x/docs/Testing.html#Integration+Tests">SBT 1.0</a> or
                        <a href="https://www.scala-sbt.org/0.13/docs/Testing.html#Integration+Tests">SBT 0.13</a> to make it part of your build.
                        Then you can add ScalaWebTest to your project as follows.</p>
                     {% code scala %}
libraryDependencies += "org.scalawebtest" %% "scalawebtest-core" % "{{page.scalaWebTestVersion}}" % "it" {% endcode %}

                    <p>ScalaWebTest uses the <b>slf4j-api</b> to write to the console or logfiles.
                        If your project does not contain an implementation of the Slf4j Logger, add the following dependency.</p>
                     {% code scala %}
libraryDependencies += "org.slf4j" % "slf4j-simple" % "{{page.slf4jVersion}}" {% endcode %}
                    <p>If you want to manage the most important transitive dependencies of ScalaWebTest, you might
                        configure it as follows (replace "it" with "test", if you do not make use of the IntegrationTest
                        configuration).
                        Especially selenium-java and htmlunit-driver have to align with each other.</p>

                     {% code scala %}
libraryDependencies ++= Seq(
    "org.scalawebtest" %% "scalawebtest-core" % "{{page.scalaWebTestVersion}}" % "it",
    "org.scalatest" %% "scalatest" % "3.0.8" % "it",
    "org.seleniumhq.selenium" % "selenium-java" % "3.141.59" % "it",
    "org.seleniumhq.selenium" % "htmlunit-driver" % "2.35.1" % "it"
) {% endcode %}
                    <h4 id="swt_maven">Add ScalaWebTest to your maven project</h4>
                    <p>You have to add the following dependency to your maven project to use ScalaWebTest.</p>

                     {% code xml %}
<dependency>
    <groupId>org.scalawebtest</groupId>
    <artifactId>scalawebtest-core_2.13</artifactId>
    <version>{{page.scalaWebTestVersion}}</version>
    <scope>test</scope>
</dependency> {% endcode%}

                    <p>ScalaWebTest uses the <b>slf4j-api</b> to write to the console or logfiles.
                        If your project does not contain an implementation of the Slf4j Logger, add the following dependency.</p>
                                         {% code xml %}
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>{{page.slf4jVersion}}</version>
    <scope>test</scope>
</dependency> {% endcode%}
                    <p>ScalaWebTest is also available for Scala 2.12 and 2.11, change the version after the underscore,
                        to get a ScalaWebTest version which is binary compatible with the one you are using.</p>

                     {% code xml %}
<dependency>
    <groupId>org.scalawebtest</groupId>
    <artifactId>scalawebtest-core_2.12</artifactId>
    <version>{{page.scalaWebTestVersion}}</version>
    <scope>test</scope>
</dependency> {% endcode%}

                    <p id="bom">In case you want to manage the most important transitive dependencies of ScalaWebTest,
                        you can add our bill-of-materials to your project. Just add the following to your dependencyManagement.</p>

                     {% code xml %}
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.scalawebtest</groupId>
            <artifactId>scalawebtest-bom_2.13</artifactId>
            <version>{{page.scalaWebTestVersion}}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement> {% endcode%}


                    <h3 id="firsttest">Write your first test</h3>
                    <p>To write your first test, you have to create a scala file in src/it/scala or src/test/scala,
                        depending on your test setup.
                        Lets assume we want to verify our homepage. Create a class named HomepageSpec, and let it extend
                        IntegrationFlatSpec. This uses <a href="http://www.scalatest.org/user_guide/selecting_a_style">FlatSpec
                            style</a> from ScalaTest, other <a href="#teststyles">styles</a> are available.</p>

                     {% code scala %}
import org.scalawebtest.core.IntegrationFlatSpec
import org.openqa.selenium.By

class HomepageSpec extends IntegrationFlatSpec {
  config.useBaseUri("https://www.scalawebtest.org")
  path = "/index.html"

  "Our homepage" should "contain a succinct claim" in {
    webDriver
      .findElement(By.tagName("h2"))
      .getText shouldEqual "Reduce the effort needed to write integration tests"
  }
} {% endcode%}
                    <a href="https://scastie.scala-lang.org/DaniRey/HuZB9METSSqu32QZmT7pcw/2" target="_blank">Try it in Scastie</a>

                    <p>That's all you need. The IntegrationSpec, inherited from IntegrationFlatSpec will automatically
                        call https://www.scalawebtest.org/index.html
                        before executing a test. When using FlatSpec style the block following the <b>in</b> keyword is
                        the body of the test.
                        Within the body of a test you can access the webDriver, to test the content of the current page.
                        The webDriver by default backed by HtmlUnit.
                        It emulates a browser and supports among other things JavaScript execution, clicking elements
                        and submitting forms.
                        HtmlUnit has its limitations with JavaScript and it is always headless, for those that need more
                        advanced features
                        we recommend <a href="#browsers/seleniumChrome">SeleniumChrome</a>.</p>

                    <h3 id="firstGauge">Write your first gauge</h3>
                    <p>This test can be rewritten making use of the HtmlGauge. <a href="#writingGauges">Writing
                        gauges</a> provides a detailed introduction to this feature.</p>

                     {% code scala %}
import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.core.gauge.HtmlGauge

class HomepageSpec extends IntegrationFlatSpec with HtmlGauge {
  config.useBaseUri( "http://www.scalawebtest.org")
  path = "/index.html"

  "Our homepage" should "contain a succinct claim" in {
    currentPage fits <h2>Reduce the effort needed to write integration tests</h2>
  }
} {% endcode%}

                    <a href="https://scastie.scala-lang.org/DaniRey/aOD6RFqwSgynejH7CNl6qQ/2" target="_blank">Try it in
                        Scastie</a>
                </section>
                <section>
                    <header>
                        <h2 id="structuringYourProject">Structuring your project</h2>
                    </header>
                    <h3 id="basetrait">Build your base class</h3>
                    Configurations, style choice and possible custom extension should be shared across your project. To
                    do so, we recommend to create an abstract base class, which is extended by all your tests.
                    ScalaWebTest uses this concept for it's own integration tests as well.
                    Instead of an abstract class one could use a trait as well. This was our recommendation for earlier
                    versions,
                    but using an abstract class improves your compilation time, therefore we recommend it over traits.

                     {% code scala %}
import org.scalatest.AppendedClues
import org.scalatest.concurrent.PatienceConfiguration.Timeout
import org.scalatest.time.SpanSugar._
import org.scalawebtest.core.gauge.HtmlGauge
import org.scalawebtest.core.{FormBasedLogin, IntegrationFlatSpec}

import scala.language.postfixOps

abstract class MyProjectBaseSpec extends IntegrationFlatSpec with FormBasedLogin with AppendedClues with HtmlGauge {
    config.useBaseUri("http://localhost:9090")
    loginConfig.useLoginUri("http://localhost:9090/login.php")

    override def loginTimeout = Timeout(5 seconds)
} {% endcode %}

                    This abstract base class uses FlatSpec style, FormBasedLogin, AppendedClues and HtmlGauge. It
                    configures host, loginPath and projectRoot and sets a suitable loginTimeout.
                    Our <a href="https://github.com/unic/ScalaWebTest/tree/master/scalawebtest-integration/src/it">integration
                    tests</a> have two purposes.
                    Not only do we use them to test our framework, but we also use it as documentation. They are a good
                    starting point when looking for best practice,
                    on how to make the most out of ScalaWebTest.

                    <h3 id="teststyles">Selecting a style</h3>
                    <p>ScalaTest provides a wide variety of testing <a
                            href="http://www.scalatest.org/user_guide/selecting_a_style">styles</a>.
                        ScalaWebTest supports all available styles.
                        As we believe the FlatSpec style is easy to read for most people, we choose it for our own
                        documentation and most of our integration tests.
                        There is no technical reason behind it, it is simply a matter of taste.
                        We recommend that you extend one of the Integration*Spec/Suite classes from <a
                                href="https://github.com/unic/ScalaWebTest/blob/master/scalawebtest-core/src/main/scala/org/scalawebtest/core/Styles.scala">Styles.scala</a>
                        in your abstract base class.
                    </p>

                    <h3 id="config">Configure your tests</h3>
                    <p>A reasonable default configuration is provided, which can easily be adapted. If you want to
                        change a configuration for all your tests, we recommend to change it in your base trait,
                        otherwise best
                        practice is to change it in the constructor of your TestSpec.
                        Two config objects exist, one which is used during login (if login is used)
                        and one which is used during test execution.
                    </p>

                    <p>In the following TestSpec JavaScript errors are swallowed during Login phase, no matter if
                        JavaScript execution is enabled or disable.
                        During test execution JavaScript is enabled and JavaScript errors let the test fail.</p>
                     {% code scala %}
import org.openqa.selenium.By
import org.scalawebtest.core.IntegrationFlatSpec

class HomepageSpec extends IntegrationFlatSpec {
  config.useBaseUri("http://www.scalawebtest.org/index.html")

  loginConfig.swallowJavaScriptErrors()
  config.enableJavaScript(throwOnError = true)

  "Our homepage" should "contain a succinct claim" in {
    webDriver
      .findElement(By.tagName("h2"))
      .getText shouldEqual "Reduce the effort needed to write integration tests"
  }
} {% endcode%}
                    <a href="https://scastie.scala-lang.org/DaniRey/jeQ90Gt6TeSnP8Cp0aUSRg/2">Try it in Scastie</a>

                    <p>By default JavaScript is not executed and JavaScript errors don't throw. Also CSS is not
                        interpreted. This applies to both loginConfig and config.</p>
                </section>

                <section>
                    <header>
                        <h2 id="writingGauges">Writing gauges</h2>
                    </header>

                    <h3 id="usingGauges">Using gauges</h3>

                    <p>Using <b>gauges</b> to write your integration tests, is the core idea of ScalaWebTest. We believe
                        Selenium has good primitives to navigate a website (triggering events, filling forms), but the
                        tools to verify the
                        resulting output are lacking. We are convinced that the HTML DOM is what should be verified. An
                        alternative would be visual tests,
                        but those tend to be brittle and it is difficult to test only a certain aspect of the page. But
                        a few of them might be a valuable addition.
                        using org.scalatest.selenium.WebBrowser.Query, i.e CssSelectorQuery,
                        to select elements in a HTML document and then verifying it is cumbersome and resulting tests
                        are hard to read.
                        Instead we borrow a concept from the manufacturing industry.
                        They build gauges (or templates), which they then lay their workpiece into. If the workpiece
                        fits in the gauge,
                        it satisfies the requirements.</p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/caliper_gauge.jpg" alt="caliper gauge">
                                <figcaption><b>caliper gauge:</b> if the workpiece fits the red side it is too small, if
                                    it doesn't fit the other side it is too big
                                </figcaption>
                            </figure>
                        </div>

                        <div class="flex_column_two">
                            <figure class="column_two">
                                <img src="images/limit_plug_gauge.jpg" alt="limit plug gauge">
                                <figcaption><b>limit plug gauge:</b> if the red side fits the boring it is too big, if
                                    the other side doesn't fit it is too small
                                </figcaption>
                            </figure>
                        </div>
                    </div>

                    <p>Our gauges are defined in HTML
                        (XML literals to be more precise, or <a
                                href="http://www.scala-lang.org/files/archive/api/2.12.1/scala-xml/scala/xml/NodeSeq$.html">scala.xml.NodeSeq</a>
                        to be exact)
                        instead of being forked from steel.
                        Let's have a look at a simple example to get an idea how those gauges work. When the browser
                        receives HTML it parses it into a DOM (document object model) tree.
                        This is also the abstraction, with which we work in ScalaWebTest. Let's first have a look at the
                        document, which we would like to test with a gauge,
                        and its representation as DOM tree.</p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                            {% code html caption=index.html %}
<!DOCTYPE html>
<html lang="en">
<head><title>ScalaWebTest Homepage</title></head>
<body>
<div>
    <ul>
        <li>
            <a href="https://scalatest.org"
               class="nav active">
                Scala Test
            </a>
        </li>
        <li>
            <a href="https://unic.com"
               class="nav">
                Unic
            </a>
        </li>
    </ul>
</div>
</body>
</html>
                            {% endcode %}
                        </div>
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/illustrations/HtmlGauge/document.png" alt="DOM tree of index.html"/>
                                <figcaption>DOM tree of index.html</figcaption>
                            </figure>
                        </div>
                    </div>

                    <p>
                        We would like to verify if the following gauge fits the above document. The gauge itself is also
                        parsed into a DOM tree.
                    </p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                        {% code scala caption="spec with gauge definition" %}
import org.scalawebtest.core.IntegrationFlatSpec

class HtmlGauge extends IntegrationFlatSpec {
  config.useBaseUri("http://localhost:8080")
  path = "index.html"

  "index.html" should "contain a nav item for Unic" in {
    currentPage fits
      <div>
        <ul>
          <li>
            <a href="https://unic.com">Unic</a>
          </li>
        </ul>
      </div>
  }
}
                        {% endcode %}
                        </div>
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/illustrations/HtmlGauge/gauge_definition.png"
                                     alt="DOM tree of gauge definition"/>
                                <figcaption>DOM tree of gauge definition</figcaption>
                            </figure>
                        </div>
                    </div>

                    <p>
                        Let's have a closer look at how ScalaWebTest checks if the document fits the gauge. On the right
                        hand
                        side you can see the DOM tree of the gauge, on the left hand side the document. The right hand
                        side
                        drives the verification process. For every element/attribute in the gauge, an according
                        element/attribute
                        has to be found in the document.
                    </p>

                    <div class="flex_row">
                        <figure>
                            <img src="images/illustrations/HtmlGauge/HtmlGauge.gif"
                                 alt="Trying to fit document into gauge">
                            <figcaption>Trying to fit document into gauge</figcaption>
                        </figure>
                    </div>


                    <p>We can see that <code>currentPage fits</code> ignored <code>html</code>, <code>head</code> and
                        <code>body</code>, elements
                        before the navigation. ScalaWebTests gauges do not only allow for gaps in your gauge definition,
                        such gaps are encouraged.
                        The idea is to make tests stable and vocal about their intend, by focusing on the elements and
                        attributes, which matter for a specific test.
                    </p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                            {% code html caption=index.html %}
<!DOCTYPE html>
<html lang="en">
<head><title>ScalaWebTest Homepage</title></head>
<body>
<div>
    <ul>
        <li>
            <a href="https://scalatest.org"
               class="nav active">
                Scala Test
            </a>
        </li>
        <li>
            <a href="https://unic.com"
               class="nav">
                Unic
            </a>
        </li>
    </ul>
</div>
</body>
</html>
                            {% endcode %}
                        </div>
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/illustrations/GapGauge/document.png" alt="DOM tree of index.html"/>
                                <figcaption>DOM tree of index.html</figcaption>
                            </figure>
                        </div>
                    </div>

                    <p>
                        The document remains the same as in the previous example. The gauge definition is missing the
                        element <code>div</code> and <code>li</code>.
                    </p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                        {% code scala caption="spec with gauge definition" %}
import org.scalawebtest.core.IntegrationFlatSpec

class GapGauge extends IntegrationFlatSpec {
  config.useBaseUri("http://localhost:8080")
  path = "index.html"

  "index.html" should "contain a nav item for Scala Test" in {
    currentPage fits
      <ul>
        <a href="https://scalatest.org">Scala Test</a>
      </ul>
  }
}
                        {% endcode %}
                        </div>
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/illustrations/GapGauge/gauge_definition.png"
                                     alt="DOM tree of gauge definition"/>
                                <figcaption>DOM tree of gauge definition</figcaption>
                            </figure>
                        </div>
                    </div>

                    <div class="flex_row">
                        <figure>
                            <img src="images/illustrations/GapGauge/GapGauge.gif"
                                 alt="Trying to fit document into gauge">
                            <figcaption>Trying to fit document into gauge</figcaption>
                        </figure>
                    </div>

                    <p>While gaps are allowed in the gauge definition. The order of elements has to be identical for the
                        gauge definition and the document.
                        The following example illustrates this, with a document, which does not fit the provided
                        gauge.</p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                            {% code html caption=index.html %}
<!DOCTYPE html>
<html lang="en">
<head><title>ElementOrderGauge</title></head>
<body>
<div>
    <ul>
        <li>Second</li>
        <li>First</li>
    </ul>
</div>
</body>
</html>
                            {% endcode %}
                        </div>
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/illustrations/ElementOrderGauge/document.png"
                                     alt="DOM tree of index.html"/>
                                <figcaption>DOM tree of index.html</figcaption>
                            </figure>
                        </div>
                    </div>

                    <p>
                        In the document the element <code>&lt;li&gt;Second&lt;/li&gt;</code> is before <code>&lt;li&gt;First&lt;/li&gt;</code>.
                        This is not as intended and the following gauge definition expects them in natural order.
                    </p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                        {% code scala caption="spec with gauge definition" %}
import org.scalawebtest.core.IntegrationFlatSpec

class ElementOrderGauge extends IntegrationFlatSpec {
  config.useBaseUri("http://localhost:8080")
  path = "index.html"

  "index.html" should "a correcly ordered list" in {
    currentPage fits
      <div>
        <ul>
          <li>First</li>
          <li>Second</li>
        </ul>
      </div>
  }
}
                        {% endcode %}
                        </div>
                        <div class="flex_column_two">
                            <figure>
                                <img src="images/illustrations/ElementOrderGauge/gauge_definition.png"
                                     alt="DOM tree of gauge definition"/>
                                <figcaption>DOM tree of gauge definition</figcaption>
                            </figure>
                        </div>
                    </div>

                    <div class="flex_row">
                        <figure>
                            <img src="images/illustrations/ElementOrderGauge/ElementOrderGauge.gif"
                                 alt="Trying to fit document into gauge">
                            <figcaption>Trying to fit document into gauge</figcaption>
                        </figure>
                    </div>

                    <p>As expected this document does not fit the gauge. In the last step, the text of the element is
                        not verified, because even before that
                        it is known that the element <code>&lt;li&gt;Second&lt;/li&gt;</code> is at the wrong position,
                        relative to <code>&lt;li&gt;First&lt;/li&gt;</code></p>

                    <h3 id="classes">Test for classes on elements</h3>
                    <p>The class attribute is special, because it is basically an unsorted set of class attributes.
                        Usually we don't bother, if additional classes are present in our HTML and for sure we never
                        care about
                        the order.
                        ScalaWebTest therefore handles the class attribute different from the rest. Per default the
                        attribute content, has to match exactly the one you provided in your gauge, but for classes, it
                        only asserts, that
                        the classes which an element contains within your gauge definition, are all present on that
                        element in the HTML
                        document.
                        The following gauge therefore matches all the elements shown below.</p>

                    <div class="flex_row">
                        <div class="flex_column_two">
                     {% code scala caption="Gauge definition containing two classes" %}
currentPage fits
    <div class="container red"></div>{% endcode %}
                        </div>
                        <div class="flex_column_two">
                    {% code html %}
<div class="container red"></div>{% endcode %}
                    {% code html %}
<div class="red container"></div>{% endcode %}
                    {% code html caption="Three examples of fitting documents" %}
<div class="red important container main"></div>{% endcode %}
                        </div>
                    </div>

                    <h3 id="singleElements">Test single elements</h3>
                    <p>Often trying to fit the complete document into the defined <code>gauge</code> isn't the most
                        natural
                        and efficient thing to do.
                        Especially when a website contains multiple elements of the same kind, such as content cards,
                        gallery images or items of a product list. It is more natural to first <code>findAll</code>
                        those elements, and then trying to fit each element into the <code>gauge</code>.</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                    {% code scala caption="ElementGaugeSpec.scala - findAll gallery images and test if they fit the gauge"%}
import org.scalatest.AppendedClues
import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.core.gauge.HtmlElementGauge

class ElementGaugeSpec extends IntegrationFlatSpec with HtmlElementGauge with AppendedClues {
  config.useBaseUri("http://localhost:9090")
  path = "/galleryOverview.jsp"

  val imageGauge =
    <div class="columns image_columns">
      <a>
        <figure class="obj_aspect_ratio">
          <noscript>
            <img class="obj_full"></img>
          </noscript>
          <img class="obj_full lazyload"
               data-sizes="auto"></img>
        </figure>
      </a>
    </div>

  "The gallery" should "contain the expected HTML for every image" in {
    def images = findAll(CssSelectorQuery("ul div.image_columns"))

    images.size should be > 5 withClue " - gallery didn't contain the expected amount of images"

    for (image <- images) {
      image fits imageGauge
    }
  }
}{% endcode %}
                        </div></div>

                    <p>When using <a href="http://www.scalatest.org/user_guide/using_selenium">findAll</a> with a
                        <a href="http://docs.scala-lang.org/tutorials/tour/sequence-comprehensions.html">for-comprehension</a>,
                        always verify, that the expected amount of elements was found. If zero element where found, no
                        element is checked.
                        Therefore an additional check is required to make sure the test fails, if <code>findAll</code>
                        didn't return anything.</p>
                    <p>When using <code>fits</code> or <code>doesntFit</code>, the same features are available, no
                        matter if the
                        whole document, or a single element is checked. Therefore the following chapters are applicable
                        for both ways of using it.
                    </p>

                    <h3 id="contains">Test for containment</h3>
                    <p>It is common that you don't want to verify the complete attribute value, or text of an element.
                        You may use <code>@contains</code> to trigger the ContainsMatcher instead of the DefaultMatcher.
                        Thanks to this matcher, this gauge matches the following HTML element</p>

                    {% code scala %}
fit(<a href="@contains ScalaWebTest"></a>){% endcode %}

                    <p>This gauge will fit</p>

                    {% code html %}
<a href="https://github.com/unic/ScalaWebTest"></a>{% endcode %}

                    <p>The containsMatcher is also available, when matching text.</p>
                    {% code scala %}
fit(<a>@contains available</a>){% endcode %}

                    <p>This gauge will fit</p>

                    {% code html %}
<a>ScalaWebTest is available on github</a>{% endcode %}

                    <p>Hint: always add a space after the matcher annotation. We enforce this space to improve
                        readability of tests.</p>

                    <h3 id="regex">Test for regex matches</h3>
                    <p>When we want to enforce textual rules on our content, we need a more powerful Matcher. The
                        RegexMatcher is our friend.
                        It is triggered using <code>@regex</code></p>

                    {% code scala %}
fit(<a href="@regex http:\\/\\/[a-zA-Z]+\.scalawebtest.org.*,"></a>){% endcode %}

                    <p>This gauge will fit</p>
                    {% code html %}
<a href="http://www.scalawebtest.org/documentation.html"></a>{% endcode %}
                    <p>but it won't fit</p>
                    {% code html %}
<a href="http://scalawebtest.org/documentation.html"></a>{% endcode %}

                    <h3 id="negation">Negating your tests</h3>
                    <p>Sometimes you want to make sure that a certain content is not shown. For example you want to make
                        sure, that no login form is shown, when a user is logged in. Or you want to make sure that a
                        post doesn't
                        appear before it is made public. To do so you may use <code>currentPage doesNotFit</code> or
                        <code>currentPage doesntFit</code>. They are synonyms.
                        If you prefer gauges, which do not start with <code>currentPage</code>, but directly with the
                        gauge, you may use <code>doesnt fit()</code> or <code>not fit()</code>
                        Choose whatever reads better in your current context.</p>

                     {% code scala %}
import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.core.gauge.HtmlGauge

class LoggedInSpec extends IntegrationFlatSpec with HtmlGauge {
  path = "/protectedContent.jsp?username=admin&password=secret"

  "When logged in the protectedContent page" should "not show the login form" in {
    currentPage doesNotFit <form name="login_form"></form>
  }
}{% endcode %}

                    <p>In case the login form is mistakenly rendered, the following error will appear.</p>

                     {% code text %}
Current document matches the provided gauge, although expected not to!
Fitting node
<html>
<head>
    <title>Mock of a protected content page
    </title>
</head>
<body>
<form name="login_form" action="protectedContent.jsp" method="get">
    <label for="username">username
    </label>
    <input type="text" name="username" id="username">
    </input>
    <label for="password">password
    </label>
    <input type="password" name="password" id="password">
    </input>
    <button type="submit">login
    </button>
</form>
</body>
</html>
found {% endcode %}

                    <h3 id="process">Testing a complete process</h3>
                    <p>Today's web applications are of course not that static. Usually it is more interesting to test a
                        complete process.
                        Selenium has great support to do so. You can press buttons, fill and submit forms and execute
                        JavaScript.
                        As ScalaWebTest's gauges are evaluated against the same browser window, as the executed Selenium
                        commands,
                        gauges can be used to verify pre-conditions and results of actions. Remember <a
                                href="http://www.scalatest.org">ScalaTest</a> executes the tests in order.
                        As soon as an action is executed, the currentPage is updated and the next call to
                        <code>fit()</code> or <code>doesnt fit()</code> will be
                        executed against the updated page/DOM.</p>
                    <p>Lets try this out using a page with protected content. Initially a login form is shown, after
                        submitting it with correct credentials,
                        the form disappears, and the text <i>sensitive information</i> appears.</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Verify pre-conditions, change state, verify post-conditions" %}
import org.scalawebtest.core.IntegrationFlatSpec

import org.scalawebtest.core.gauge.HtmlGauge

class LoginSpec extends IntegrationFlatSpec with HtmlGauge {
  path = "/protectedContent.jsp"

  "When accessing protectedContent it" should "show the login form" in {
    currentPage fits
      <form name="login_form">
        <input name="username"></input>
        <input name="password"></input>
      </form>
  }

  it should "hide the protected content, when not logged in" in {
    currentPage doesNotFit <p>sensitive information</p>
  }

  it should "show the protected content, after logging in" in {
    textField("username").value = "admin"
    pwdField("password").value = "secret"

    submit()

    currentPage fits <p>sensitive information</p>
  }
}{% endcode %}
                        </div>
                    </div>

                    <p>This example test was split into three smaller tests. This is technically not necessary, but has
                        the following advantage. When only part of the tests fails, you have a better idea what went
                        wrong. For
                        example, if the login fails, but the login form is correctly shown, the issue has to be your
                        login process. But if the
                        login form isn't shown, the problem has a very different cause. In addition the verbose output
                        from the
                        <code>gauge</code> should help you finding the root cause.</p>

                </section>

                <section>
                    <header>
                        <h2 id="lifecycleAndConfiguration">Lifecycle and Configuration</h2>
                    </header>
                    <h3 id="lifecycle">Testing lifecycle</h3>
                    <p>ScalaTest has a same lifecycle as most testing frameworks. <code>beforeAll</code> and <code>afterAll</code> are executed first, respectively last and only once per suite (a class extending <code>IntegrationFlatSpec</code> is a suite).
                        <code>beforeEach</code> and <code></code> are executed before, respectively after every single test.
                    </p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                            <figure>
                                <img src="images/illustrations/Lifecycle/testing_lifecycle.png" alt="Default ScalaTest testing lifecycle"/>
                                <figcaption>Default ScalaTest testing lifecycle</figcaption>
                            </figure>
                        </div>
                    </div>
                    <p>
                        Tests itself are executed in the same order, as they are defined. For ScalaWebTest to manage the state of the browser for you, it has to overwrite <code>beforeAll</code> and <code>beforeEach</code>.
                        You can still overwrite <code>beforeAll</code> or <code>beforeEach</code> in your code, but remember to call <code>super.beforeAll()</code>, respectively <code>super.beforeEach()</code>.
                        With <code>beforeAll</code>, chances are, you want to have more finegranular control when your code is executed in the <code>beforeAll</code> process. Therefore ScalaWebTest provides the hook methods <code>beforeLogin</code> and <code>afterLogin</code>.
                    </p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                            <figure>
                                <img src="images/illustrations/Lifecycle/scalawebtest_lifecycle_and_hooks.png" alt="ScalaWebTest testing lifecycle and hooks"/>
                                <figcaption>ScalaWebTest testing lifecycle and hooks</figcaption>
                            </figure>
                        </div>
                    </div>
                    <h3 id="configuration">Configuration</h3>
                    <p>To change configurations for a test execution, ScalaWebTest reads system properties, environment variables and <code>Runner</code> arguments.
                        They are tried in the following order, with the first one being defined winning. The rule of precedence is <code>Runner</code> arguments environment variables over system properties.
                        While lowercase and dot separated is idiomatic for system properties, uppercase and underscore separated is idiomatic for environment variables in Unix and Linux (dots are not allowed). Therefore we have the following rule.
                    </p>
                    <ul>
                        <li>Runner arguments are lowercase and dot separated, for example <code>scalawebtest.base.uri</code></li>
                        <li>Environment variables can be either
                        <ul>
                            <li>lowercase and dot separated, for example <code>scalawebtest.base.uri</code></li>
                            <li>uppercase and underscore separated, for example <code>SCALAWEBTEST_BASE_URI</code></li>
                        </ul>
                        </li>
                        <li>System properties arguments are lowercase and dot separated, for example <code>scalawebtest.base.uri</code></li>
                    </ul>

                    <p>The following configurations are always available</p>
                    <ul>
                        <li><code>scalawebtest.login.uri</code></li>
                        <li><code>scalawebtest.base.uri</code></li>
                    </ul>
                    <p>While these are specific to chrome</p>
                    <ul>
                        <li><code>webdriver.chrome.driver.service.url</code></li>
                        <li><code>webdriver.chrome.driver</code></li>
                        <li><code>webdriver.chrome.arguments</code></li>
                    </ul>

                    <p>ScalaWebTest informs its users about found and used configurations via log output.</p>

                    <div class="flex_row">
                        <div class="flex_column_one">
                    {% code bash caption="ScalaWebTest configuration specific log information" %}
[ScalaTest-run] INFO org.scalawebtest.core.IntegrationSpec$$anon$1 - No ConfigMap entry (runner argument) scalawebtest.login.uri found
[ScalaTest-run] INFO org.scalawebtest.core.IntegrationSpec$$anon$1 - No environment variable scalawebtest.login.uri found
[ScalaTest-run] INFO org.scalawebtest.core.IntegrationSpec$$anon$1 - No environment variable SCALAWEBTEST_LOGIN_URI found
[ScalaTest-run] INFO org.scalawebtest.core.IntegrationSpec$$anon$1 - No system property scalawebtest.login.uri found
[ScalaTest-run] INFO org.scalawebtest.core.IntegrationSpec$$anon$2 - ConfigMap entry (runner argument) scalawebtest.base.uri found with value http://www.scalawebtest.org
[ScalaTest-run-running-ResponseHeaderValueSpec] INFO org.scalawebtest.integration.doc._012.ResponseHeaderValueSpec - Going to http://www.scalawebtest.org/responseHeaders.jsp
                    {% endcode %}
                        </div>
                    </div>

                    <p>Your own tests might add additional configurations. To do so, extend <code>Configurable</code> trait and make use of <code>configFor</code> or <code>requiredConfigFor</code>.
                        For example <code>configFor[URI](configMap)("scalawebtest.base.uri")</code>. Both methods expect the lowercase and dot separated representation of the config property.
                    </p>

                    <h3 id="arguments">Runner arguments</h3>
                    <p>To read <code>Runner</code> arguments, ScalaWebTest uses <a href="http://www.scalatest.org/user_guide/using_the_runner#configMapSection">configMap</a> from ScalaTest.
                        The arguments can be provided with <code>-Dkey=value</code>, for example <code>-Dscalawebtest.base.uri=http://localhost:8090/myapp</code>.
                    </p>

                    {% code bash caption="Use Runner with arguments" %}
scala -classpath scalatest-&lt;version&gt;.jar org.scalatest.tools.Runner -R compiled_tests -Dkey=value{% endcode %}

                    <p>The Intellij Testrunner works with arguments as well, add <code>-Dkey=value</code> to the <i>Test options</i></p>

                    <div class="flex_row">
                        <div class="flex_column_one">
                            <figure>
                                <img src="images/resources/intellij_runner.png" alt="provide arguments via intellij test runner">
                                <figcaption>Provide arguments via Intellij Test Runner</figcaption>
                            </figure>
                        </div>
                    </div>

                    <h3 id="envVars">Environment variables</h3>
                    <p>Environment variables are an alternative way to change ScalaWebTest configurations. It has lower precedence then runner arguments.
                        Environment variables are especially useful with Docker containers, as they are the de-facto standard to provide configuration to containers.</p>
                    <h3 id="systemProperties">System Properties</h3>
                    <p><a href="https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html">System properties</a> have the lowest precedence.
                        They can be set using <code>System.setProperty("key", "value");</code></p>
                </section>
                <section>
                    <header>
                        <h2 id="browserDependent">Browser dependent features</h2>
                    </header>

                    <h3 id="executingJavascript">Executing JavaScript</h3>
                    <p>With Html-Unit Driver it is possible to execute JavaScript, but some edge-cases are not covered
                        perfectly.
                        As JavaScript on the JVM is interpreted with <a
                                href="https://github.com/mozilla/rhino">Rhino</a>. For JavaScript heavy web
                        applications,
                        we recommend to use a native browser, such as <a href="#chrome">Chrome</a>.
                        Per default ScalaWebTest doesn't execute JavaScript, because tests run faster without. To
                        execute JavaScript, you have to enable it.</p>
                    {% code scala %}
 config.enableJavaScript(throwOnError = true){% endcode %}
                    <p>In addition, you have to decide whether a JavaScript error should cause your test to fail or not.
                        Usually failing on JavaScript errors is good, but sometimes you have to write tests for a web
                        application with
                        major issues in it's JavaScript. This is one of the rare moments, where you have to disable
                        <code>throwOnError</code> to be
                        able to test the web application.</p>
                    <p>After receiving document, your browser needs some time to execute JavaScript. The same is true
                        for the Selenium webdriver. We
                        have to give it some time to execute JavaScript, before we can expect it to have transformed the
                        HTML.
                        ScalaTest provides <code>eventually</code>, which does exactly what we need. It repeats a given
                        test
                        until it succeeds or the given timeout has been surpassed.</p>
                    {% code scala %}
eventually(timeout(3 seconds)) {
    fits(
        <div id="container">Text loaded with JavaScript</div>
    )
}{% endcode %}
                    <h3 id="responseCodeHeaders">Access response code and response headers</h3>
                    <p>HTTP response codes and response headers are two important parts of the HTTP protocol. Therefore
                        it is important to assert that they have the correct values.
                        The <code>ResponseAccessors</code> trait provides convenient access to this information.</p>

                    <p>The HTTP response code can be accessed with the <code>responseCode</code> method.</p>

                    <div class="flex_row">
                        <div class="flex_column_one">
                            {% code scala caption="Verifying the response code" %}
import org.scalawebtest.core.{IntegrationFlatSpec, ResponseAccessors}

class ResponseCodeSpec extends IntegrationFlatSpec with ResponseAccessors {
    path = "/doesNotExist"
    "When accessing a resource which does not exist the response code" should "be 404" in {
        responseCode shouldBe 404
    }
}{% endcode %}
                        </div>
                    </div>

                    <p>The HTTP response headers are exposed as <code>Map[String, String]</code> by the method <code>responseHeaders</code>
                    </p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                            {% code scala caption="Verifying response headers" %}
import org.scalatest.OptionValues
import org.scalawebtest.core.{IntegrationFlatSpec, ResponseAccessors}

class ResponseHeadersSpec extends IntegrationFlatSpec with ResponseAccessors with
    OptionValues{
    path = "/responseHeaders.jsp"
    "The responseHeaders map" should "contain the Content-Type" in {
        responseHeaders should not be empty
        responseHeaders.keySet should contain("Content-Type")
        responseHeaders.get("Content-Type").value shouldBe "text/html; charset=UTF-8"
    }
}{% endcode %}
                        </div>
                    </div>
                    <p>The <code>responseHeaderValue</code> method simplifies the common "verifying that response header
                        X has value Y" use-case.</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                            {% code scala caption="Verifying response header values" %}
import org.scalawebtest.core.{IntegrationFlatSpec, ResponseAccessors}

class ResponseHeaderValueSpec extends IntegrationFlatSpec with ResponseAccessors {
    config.useBaseUri("http://localhost:9090")
    path = "/responseHeaders.jsp"

    "The responseHeaderValue of Content-Type" should "be text/html with charset utf-8" in {
        responseHeaderValue("Content-Type") shouldBe "text/html;charset=utf-8"
    }
    "The responseHeaderValue" should "merge response header field-values, when multiple entries with the same field-name exist" in {
        /**
        * Cache-Control: no-cache
        * Cache-Control: no-store
        *
        * should be merged into
        *
        * Cache-Control: no-cache, no-store
        *
        * See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9 for details
        */
        responseHeaderValue("Cache-Control") shouldBe "no-cache, no-store"
    }
}{% endcode %}
                        </div>
                    </div>
                    <p>Although response headers name should not be case sensitive according to <a
                            href="https://tools.ietf.org/html/rfc7230#section-3.2">HTTP/1.1 specification</a> this isn't
                        necessarily true for all implementations.
                        We believe a testing framework shouldn't obfuscate what's sent over the wire. Therefore we
                        expose the HTTP response headers in case-sensitive fashion.</p>
                    <p>Unfortunately, we can provide those accessors only in combination with <code>HtmlUnit</code>
                        webdriver (the default webdriver with ScalaWebTest).
                        The Selenium webdriver interface and most of it's implementations do not expose the needed
                        information.
                        Details on those limitations can be found in <a
                                href="https://github.com/unic/ScalaWebTest/issues/74#issuecomment-479185222">ScalaWebTest
                            github issue #74</a>
                        Remember, you can use multiple browsers within your tests.</p>

                    <h3 id="otherBrowsers">Other Browsers</h3>
                    <p>Some web applications don't behave correctly with <code>HtmlUnit</code>. Sometimes users want to see what is actually going on during test execution.
                        In this situations a headed browser is preferable over the headless and JVM based <code>HtmlUnit</code>. ScalaWebTest support all implementations
                        of Selenium Webdriver. To use a different webdriver just set webDriver to a different value, for example <code>webDriver = new MyDriver()</code>.
                        As you might need access to the <code>configMap</code>, when doing so, there is a special hook to do so <code>prepareWebDriver(configMap: ConfigMap)</code>.
                        ScalaWebTest ships with built-in <a href="#chrome">Chrome support</a>, the according classes are a good example to add support for different browsers.
                    </p>

                    <h3 id="chrome">Using Chrome</h3>
                    <p>To use Chrome in your tests extend the <code>SeleniumChrome</code> trait, install <a href="http://chromedriver.chromium.org/">ChromeDriver</a> on the executing machine and provide the
                    <code>webdriver.chrome.driver</code> configuration. ScalaWebTest will manage the ChromeDriverService and run it with suitable arguments. If you prefer to manage ChromeDriverService yourself,
                    use <code>webdriver.chrome.driver.service.url</code> instead and make sure it is running before executing the test. The arguments for ChromeDriverService can be overwritten using <code>webdriver.chrome.arguments</code> configuration.
                    The <a href="#configuration">Configuration</a> chapter describes all possiblities to set those configurations.</p>
                </section>
                <section>
                    <header>
                        <h2 id="docker">Running ScalaWebTest in docker</h2>
                    </header>
                    <p>Docker is a useful tool. We believe running ScalaWebTest in a docker container can be a good solution in multiple scenarios. When using it in none-JVM based projects,
                        in projects which containerize their complete build process or to quickly try it out.</p>
                    <h3 id="defaultImage">Using the default image</h3>
                    <p>The <a href="https://hub.docker.com/r/scalawebtest/sbt">scalawebtest/sbt</a> image is a good starting point. Provide your tests with via an according volume and you are ready to go.</p>
                    <h3 id="ownImage">Building your own image</h3>
                    <p>An interesting option is to build an own docker image, containing the compiled tests. This image can then be used to run regression tests against different environments. This might be even used as part of your monitoring.
                        The <a href="https://github.com/unic/ScalaWebTest/tree/master/examples/docker">docker example</a> shows the easiest way to achieve this and how it can be combined with using <a href="https://hub.docker.com/r/scalawebtest/sbt">scalawebtest/sbt</a>
                        during test development.
                    </p>
                </section>

                <section>
                    <header>
                        <h2 id="additionalModules">Additional modules</h2>
                    </header>

                    <h3 id="modules">Modules</h3>

                    <p>Every web application framework has its own specialities, which are relevant for testing.
                        ScalaWebTest allows to share this framework specific logic via modules. We encourage others, to
                        create additional modules for their most used framework.</p>
                    <p>What should be shared via modules?</p>
                    <p>We think even simple things such as default login method, ports and urls might be worth sharing.
                        Functions to create content, update accounts, or requesting a page in debug mode, could be even
                        better candidates for a module.</p>
                    <h3 id="modules_aem">AEM module</h3>
                    <p>As the creators of ScalaWebTest work a lot with Adobe Experience Manager, they decided to create
                        the first module for this CMS</p>
                    <p>To use this module extend <code>AemTweaks</code> from the <i>aem</i> module in your BaseTrait.
                        This will cause the following.</p>
                    <ul>
                        <li><code>FormBasedLogin</code> is activated</li>
                        <li><code>loginUri</code> is set to the default AEM 6 login path</li>
                        <li>pages are requested with <code>wcmmode</code> cookie set to <code>DISABLED</code></li>
                    </ul>
                    <h4 id="modules/aem/pageproperties">PageProperties</h4>
                    <p>
                        The <a href="https://github.com/unic/ScalaWebTest/blob/master/scalawebtest-aem/src/main/scala-2.11/org/scalawebtest/aem/PageProperties.scala">PageProperties</a>
                        trait populates the pageProperties, and if applicable componentProperties and suffixProperties fields with a
                        <a href="https://www.playframework.com/documentation/2.5.x/api/scala/index.html#play.api.libs.json.JsValue">JsValue</a>
                        representing the properties of the currentPage, component and suffix respectively. It does so by retrieving the JSON representation of
                        the currentPage. This works by default on all CQ/AEM author instances. In addition it provides convenience methods to access the pageProperties content.
                    </p>
                    <ul>
                        <li>pageProperties(name: String) - retrieve a page property by name</li>
                        <li>jcrContent(name: String) - retrieve a property from jcr:content by name</li>
                        <li>findByResourceType(value: String) - search through a parsys field in the pageProperties and
                            find all component with given resourceType
                        </li>
                        <li>findByProperty(name: String)(value: String) - search through a parsys field in the
                            pageProperties and find all component with given property name and value
                        </li>
                    </ul>

                    <p>
                        It populates the <code>pageProperties</code> field with a <code>play.api.libs.json.JsValue</code>, which
                        represents the properties of the currentPage. In case the <i>url/path</i> points to something below jcr:content, the
                        <code>componentProperties</code> will be populated with the properties
                        of the component, and the <code>pageProperties</code> with those of the containing page.
                        In case the <i>url/path</i> contains a suffix, the <code>suffixProperties</code> will be populated
                        with the properties of the page referenced in the suffix.
                        It does so by manipulating the <i>url</i> field, to request the JSON representation of the
                        currentPage from CQ/AEM.
                        This feature is available on CQ/AEM author instances by default. The <code>enable.json</code>
                        property of the <code>org.apache.sling.servlets.get.DefaultGetServlet</code> of your CQ/AEM instance has to be
                        set to true.

                        Only extend this trait in tests which need the feature, as it otherwise unnecessarily slows down your tests,
                        due to additional requests for page properties.
                    </p>
                    <h3 id="modules_json">JSON module</h3>
                    <p>JSON is currently the most important data exchange format in the web. We think writing
                        integration tests for web-services, which return JSON, should be as easy as for websites.
                        Therefore we created the <code>JsonGauge</code>, which provides functionality comparable to the
                        <a href="#gauges">HtmlGauge</a>. All its features are exposed via the according builder, which
                        provides implicit conversions for JsValue, JsLookup and functions retrieving the currentPage
                        from the webDriver.
                        We choose to use <a href="https://www.playframework.com/documentation/2.7.x/ScalaJson">play-json</a> to
                        parse the JSON response. To keep the core module clean from additional dependencies a module was created.
                    </p>
                    <h4 id="modules/json/aFewValues">Only verifying a few values</h4>
                    <p>To verify the value or type of a few values, we consider standard play-json sufficient. Just use
                        <code>Json.parse</code> to parse the response and then use <code>\</code> and <code>\\</code> to
                        navigate the json structure.</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Testing JSON with plain play-json" %}
import org.scalawebtest.core.IntegrationFlatSpec
import play.api.libs.json.Json

class ReducedJsonSpec extends IntegrationFlatSpec {
    path = "/dijkstra.json"
    def json = Json.parse(webDriver.getPageSource)

    "Dijkstra" should "have the correct firstname" in {
        def firstName = (json \ "firstName").as[String]
        firstName should equal("Edsger")
    }
}{% endcode %}
                        </div>
                    </div>
                    <p>All JSON tests in the following examples use the following JSON response</p>
                    <div id="modules/json/testResponse">
                        <div class="flex_row">
                            <div class="flex_column_one">
                         {% code json caption="JSON used in examples: dijkstra.json" %}
{
  "name": "Dijkstra",
  "firstName": "Edsger",
  "yearOfBirth": 1930,
  "theories": [
    "shortest path",
    "graph theory"
  ],
  "isTuringAwardWinner": true,
  "universities": [
    {
      "name": "Universität Leiden",
      "begin": 1948,
      "end": 1956
    },
    {
      "name": "Mathematisch Centrum Amsterdam",
      "begin": 1951,
      "end": 1959
    },
    {
      "name": "Technische Universiteit Eindhoven",
      "begin": 1962,
      "end": 1984
    },
    {
      "name": "University of Texas at Austin",
      "begin": 1984,
      "end": 1999
    }
  ]
}{% endcode %}
                            </div>
                        </div>
                    </div>
                    <p>As this way of verifying JSON doesn't scale well, we created <code>JsonGauge</code></p>
                    <h4 id="modules/json/gauge">JsonGauge - the ScalaWebTest way</h4>
                    <p>Same as when verifying HTML, we think the easiest and most natural way to formulate your
                        expectation is using the same language, as the tested response itself.
                        With the JSON gauge you can use JSON to specify the gauge, into which the JSON response has to fit.
                    </p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Testing the response as a whole" %}
import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.json.JsonGauge
import org.scalawebtest.json.JsonGaugeFromResponse.fitsValues

class DocumentFitsValuesSpec extends IntegrationFlatSpec with JsonGauge {
  path = "/dijkstra.json"

  "FitsValues" should "report success, when the json gauge contains the same values as the response it is tested against" in {
    fitsValues(
      """{
            "name": "Dijkstra",
            "firstName": "Edsger",
            "yearOfBirth": 1930,
            "isTuringAwardWinner": true,
            "theories": [
                "shortest path",
                "graph theory"
            ]
            }"""
    )
  }
}{% endcode %}
                        </div>
                    </div>
                    <p>Often verifying the complete response isn't ideal. We recommend to parse and traverse the
                        document using <a href="https://www.playframework.com/documentation/2.7.x/ScalaJson">play-json</a> and
                        then verify if the <code>JsLookup</code> or <code>JsValue</code> <code>fits</code> the defined gauge.</p>
                        <div class="flex_row">
                            <div class="flex_column_one">
                     {% code scala caption="Testing JsValue and JsLookup" %}
import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.json.JsonGauge
import play.api.libs.json.Json

class JsValueJsLookupFitsValues extends IntegrationFlatSpec with JsonGauge {
  path = "/dijkstra.json"
  def dijkstra = Json.parse(webDriver.getPageSource)

  "The response for Dijkstra" should "contain the expected values" in {
    dijkstra fits values of
      """{
          "firstName": "Edsger",
          "name": "Dijkstra",
          "yearOfBirth": 1930,
          "theories": [
              "shortest path",
              "graph theory"
              ]
          }
      """
  }
  it should "contain the correct universities" in {
    val universities = dijkstra \ "universities"
    universities fit values of
      """
        [
            { "name": "Universität Leiden","begin": 1948, "end": 1956 },
            { "name": "Mathematisch Centrum Amsterdam", "begin": 1951, "end": 1959 },
            { "name": "Technische Universiteit Eindhoven", "begin": 1962, "end": 1984 },
            { "name": "University of Texas at Austin", "begin": 1984, "end": 1999 }
        ]
        """
  }
}{% endcode %}
                            </div>
                        </div>
                    <p>As with the HTML gauge, controlled variance is allowed. The original <a href="#modules/json/testResponse">response</a>
                        contains additional key/value pairs (<code>isTuringAwardWinner</code> and <code>universities</code>).
                        Also the order of the <code>name</code> and <code>firstName</code> is the other way around.
                        Nevertheless this test would succeed, when run. It would report an error, if the response would:</p>
                    <ul>
                        <li>contain a different value for one of the keys</li>
                        <li>miss a key, which is contained in the gauge</li>
                        <li>contain a different hierarchy of the key/value pairs</li>
                    </ul>
                    <p><a href="http://www.scalatest.org/user_guide/sharing_tests">Behaviors</a> are a good way to share
                        tests. When sharing test via behaviors, verifying values is often too specific. Therefore we
                        provide <code>fits types of</code> in addition to <code>fits values of</code>.
                    </p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Testing only the types of a JSON" %}
import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.json.JsonGauge
import play.api.libs.json.Json

class FitsTypeSpec extends IntegrationFlatSpec with JsonGauge {
  path = "/dijkstra.json"

  def dijkstra = Json.parse(webDriver.getPageSource)

  "The response for Dijkstra" should "contain the expected types" in {
    dijkstra fits types of
      """{
            "firstName": "",
            "name": "",
            "yearOfBirth": 0,
            "theories": [ "" ]
        }
    """
  }
}{% endcode %}
                        </div>
                    </div>
                    <p>Now the values no longer matter. They are only used to determine the expected type. Therefore we
                        recommend to use values, which indicate that only the type matters. Use empty strings and 0.
                        This test would succeed. It would fail, when the response would:</p>
                    <ul>
                        <li>contain a value with a type different from the one expected for the given key</li>
                        <li>miss a key, which is contained in the gauge</li>
                        <li>contain a different hierarchy of the key/value pairs</li>
                        <li>when an array value would contain an element with a mismatching type</li>
                    </ul>
                    <p>Lets have a closer look at arrays. Usually we expect all array elements to match certain
                        expectations. When using <code>fits types of</code>, you only have to define those expectations once.
                        All array elements then have to fulfill them. Lets have a look at an example. Lets assume the
                        test of the previous example would be replaced with the following</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Testing the types of array elements" %}
"The response for Dijkstra" should "contain the expected types" in {
    dijkstra fits types of
        """{
            "firstName": "",
            "name": "",
            "yearOfBirth": 0,
            "theories": [ "" ]
            "universities":
            [{
                "name": "",
                "begin": 0,
                "end": 0
            }]
        }
        """
} {% endcode %}
                        </div>
                    </div>
                    <p>This would enforce all elements of the <code>universities</code> array to contain a key <code>name</code>
                        with a value of type <code>string</code> and the keys <code>begin</code> and <code>end</code>
                        with a value of type <code>number</code>.
                        The elements might contain additional keys, such as <code>department</code>, but no contradictions.
                        Sometimes this is not the behavior one is looking for. Two more options exist to verify arrays.
                        One common scenario is, that the size of the array matters, i.e. coordinates in a <a href="http://geojson.org/">GeoJson</a> document.
                        To test this use <code>fits typesAndArraySizes of</code>.
                        In this case every array element is considered unique, you have to provide specific expectations
                        for every element, but those expectations are allowed to differ.
                        For example, we expect Martin to have studied and worked at three universities. For the first
                        two an <code>end</code> is known. This isn't the case for the last one.</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Testing the types and size of arrays" %}
"The response for Odersky" should "contain the expected types and array sizes" in {
    odersky fits typesAndArraySizes of
        """{
            "firstName": "",
            "name": "",
            "universities":
        [{
            "name": "",
            "begin": 0,
            "end": 0
        },
        {
            "name": "",
            "begin": 0,
            "end": 0
        },
        {
            "name": "",
            "begin": 0
        }]
        }
        """
} {% endcode %}
                        </div>
                    </div>
                    <p>One more common situation exists with arrays. Often the array elements are not sorted. Although
                        we expect the array to contain a specific element, we don't know it's position.
                        For this situation <code>containsElementFitting values/types/typesAndArraySizes of</code> exists.</p>
                    <div class="flex_row">
                        <div class="flex_column_one">
                     {% code scala caption="Search arrays for fitting elements" %}
package org.scalawebtest.documentation

import org.scalawebtest.core.IntegrationFlatSpec
import org.scalawebtest.json.JsonGauge
import play.api.libs.json.{JsLookupResult, JsValue, Json}

class ContainsElementFittingSpec extends IntegrationFlatSpec with JsonGauge {
    path = "/jsonResponse.json.jsp"
    def dijkstra: JsValue = Json.parse(webDriver.getPageSource)
    def universities: JsLookupResult = { dijkstra \ "universities" }

    "The universities array" should "contain an element with the expected types" in {
        universities containsElementFitting types of
            """{
                | "name": "",
                | "begin": 0,
                | "end": 0
                | } """.stripMargin
    }
    it should "contain an element with the expected values" in {
        universities containsElementFitting values of
            """{
                | "name": "Technische Universiteit Eindhoven",
                | "begin": 1962,
                | "end": 1984
                | }""".stripMargin
    }
} {% endcode %}
                        </div>
                    </div>
                    <p>If we know all elements of an array, but we do not know their position, we can use <code>fits valuesIgnoringArrayOrder of</code> instead of checking only for a single one with <code>containsElementFitting</code>.</p>

                    <div class="flex_row">
                        <div class="flex_column_one">
                    {% code scala caption="Testing the values of array elements, but ignoring the order of the elements" %}
import org.scalawebtest.integration.json.{FitsTypeMismatchBehavior, ScalaWebTestJsonBaseSpec}
import play.api.libs.json.{JsValue, Json}

class FitsValuesIgnoringArrayOrderSpec extends ScalaWebTestJsonBaseSpec with FitsTypeMismatchBehavior {
  path = "/dijkstra.json"

  def dijkstra: JsValue = Json.parse(webDriver.getPageSource)

  "Dijkstra" should "contain the correct firstName and lastName and the correct universities in any order" in {
    dijkstra fits valuesIgnoringArrayOrder of
      """
        |{
        | "name": "Dijkstra",
        | "firstName": "Edsger",
        | "universities":
        | [
        |   { "name": "Universität Leiden","begin": 1948, "end": 1956 },
        |   { "name": "University of Texas at Austin", "begin": 1984, "end": 1999 },
        |   { "name": "Technische Universiteit Eindhoven", "begin": 1962, "end": 1984 },
        |   { "name": "Mathematisch Centrum Amsterdam", "begin": 1951, "end": 1959 }
        | ]
        |}
      """.stripMargin
  }
}{% endcode %}
                        </div>
                    </div>
                    <h4 id="modules/json/alternatives"></h4>
                    <p>
                        Because of its simplicity we prefer <a href="https://www.playframework.com/documentation/2.7.x/ScalaJson">play-json</a> over
                        <a href="http://argonaut.io/">Argonaut</a> or <a href="https://circe.github.io/circe/">Circe</a>.
                        A good alternative to our JSON module is <a href="http://agourlay.github.io/cornichon/">cornichon</a>.
                        Cornichon requires your tests to be a bit more specific then the ScalaWebTest ones, but it
                        provides nice ways to do so.
                        As cornichon uses Akka Http instead of Selenium to retrieve the JSON response, it is only
                        partially compatible with ScalaWebTest. They might coexist in the same codebase and both are
                        based on <a href="http://www.scalatest.org/">ScalaTest</a>,
                        but cornichon can't make much use of the boilerplate reduction provided by our IntegrationSpec.
                    </p>
                </section>

                <section>
                    <header>
                        <h2 id="extendingScalaWeText">Extending ScalaWebTest</h2>
                    </header>

                    <p>One of the goals for ScalaWebTest is to make it as as easy as possible, to extend it.
                        Therefore the foreseen extension points are a part of the documentation.</p>
                    <h3 id="extending_matchers">Create a custom matcher</h3>
                    <p>One of the core extension points for gauge testing, are the matchers. ScalaWebTest uses two
                        types of matchers, one for text and one for attributes.
                        You may create your own <code>TextMatcher</code> or <code>AttributeMatcher</code> by extending
                        those traits. You can then add your own matcher, by prepending to the list of <code>textMatchers</code> or
                        <code>attributesMatchers</code> in the <code>Matchers</code> object.</p>
                    <p>
                        <a href="https://github.com/unic/ScalaWebTest/tree/master/scalawebtest-integration/src/it/scala/org/scalawebtest/integration/extending/ExtendingMatchers.scala">ExtendingMatchers.scala</a>
                        contains an example, of how to implement your own Matcher</p>
                    <h3 id="extending_login">Create a custom login</h3>
                    <p>If the available login mechanisms don't work with your web application. No worries, simply
                        create your own implementation of the <code>Login</code> interface
                        and extend it in your base trait. Ideally you then contribute it back to the project via pull request.</p>
                    <p>The <a href="https://github.com/unic/ScalaWebTest/blob/master/scalawebtest-core/src/main/scala/org/scalawebtest/core/Login.scala">FormBasedLogin</a>
                        provides a good example on how to implement your custom login</p>
                    <h3 id="extending_module">Create your own module</h3>
                    <p>If you implement multiple web applications with the same framework, you might want to create a
                        framework specific module. This allows to share framework specific testing code among multiple
                        projects. You can start using it within your company/project and share it later with the rest of the community
                        by creating a pull request. If you provide your own module to ScalaWebTest, we ask you to help maintaining it.</p>
                </section>

                <section>
                    <header>
                        <h2 id="internalStructure">Internal Structure</h2>
                    </header>

                    <h3 id="api_IntegrationSpec">IntegrationSpec</h3>

                    <p>The <code>IntegrationSpec</code> is the base trait, which all testing style specific traits extend.
                        When writing a spec you should not extend <code>IntegrationSpec</code>, but one of the testing
                        style specific traits, such as <code>IntegrationFlatSpec</code></p>
                    <p>The base trait extends the following traits</p>
                    <ul>
                        <li>Webbrowser - Selenium DSL for ScalaTest</li>
                        <li>Suite - encapsulates a conceptual suite of tests</li>
                        <li>BeforeAndAfterEach - provides beforeEach and afterEach test hooks</li>
                        <li>BeforeAndAfterAllConfigMap - provides beforeAll and AfterAll tests hooks</li>
                        <li>IntegrationSettings - a set of fields to configure IntegrationSpec</li>
                        <li>Eventually - provides <code>eventually</code> function</li>
                    </ul>
                    <h3 id="api_Integration_Spec">Integration_Spec</h3>
                    <p>There is a complete set of test style specific base traits. Choose a <a href="http://www.scalatest.org/user_guide/selecting_a_style">testing style</a>
                        and then extend the according style specific <code>Integration_Spec</code> trait to create your test.</p>
                    <p>This traits extend the following traits</p>
                    <ul>
                        <li>_Spec i.e. FlatSpec - provides the testing style specific DSL</li>
                        <li>IntegrationSpec - integrates ScalaTest and Selenium with additional features from
                            ScalaWebTest
                        </li>
                        <li>Matchers - provides DSL for assertions using the word <code>should</code></li>
                        <li>Inspectors - provides nestable inspector methods that enable assertions to be made about
                            collections
                        </li>
                    </ul>
                    <h3 id="api_SpecBehavior">_SpecBehavior</h3>
                    <p>One way to share assertions between testing suites, is to use <code>behavior</code>. A behavior
                        contains a set of assertions. You can then use <code>X behaves like SomeBehavior</code> within
                        the suite. Behavior and Suite have to use the same testing style. Therefore ScalaWebTest builds its style specific base
                        traits on the style specific behavior traits.
                        The following traits, which are part of the Integration_Spec, are in fact inherited from the behavior trait</p>
                    <ul>
                        <li>_Spec i.e. FlatSpec</li>
                        <li>Matchers</li>
                        <li>Inspectors</li>
                    </ul>
                    <h3 id="api_Gauge">Gauge</h3>
                    <p>The <code>Gauge</code> provides the methods <code>fit</code>, <code>fits</code>, <code>doesnt
                        fit</code> and <code>not fit</code>.
                        All of them are used to verify if the current page matches the given gauge specification. To
                        do so, the gauge, searches for elements, as defined by the specification, in the current webpage. Elements
                        are found by element name and containing classes. All elements which fulfill the search criteria, are considered
                        candidates. Candidates are then verified for correct attributes and text, using <code>Matchers</code>, next they
                        are verified by checking whether their children match. As soon as something doesn't match a <code>Misfit</code> is
                        reported. If no candidate matches all criteria, the gauge doesn't fit. While verifying the candidates, a list of
                        <code>Misfits</code> was acquired, the gauge will only report the most specific of all <code>Misfits</code>.
                    </p>
                    <h3 id="api_Misfit">Misfit</h3>
                    <p>A <code>Misfit</code> is a container for an error message, when something didn't fit a given
                        Matcher.
                        It contains an error message and a relevance. The deeper the current check in the gauge
                        specification is, the higher its relevance. In the end only the <code>Misfits</code> with the highest relevance will be part
                        of the error message.
                    </p>
                    <h3 id="api_Matchers">Matchers</h3>
                    <p>When working with <code>gauges</code> for testing, <code>Matchers</code> are used to test
                        attributes and text content of elements. By default the following <code>Matchers</code> are available.</p>
                    <ul>
                        <li>Default Matcher: tests whether an attribute or text exactly matches a given String</li>
                        <li>Contains Matcher: tests whether an attribute or text contains a given String</li>
                        <li>Regex Matcher: tests whether an attribute or text matches the given Regex</li>
                    </ul>
                    <p>All <code>Matchers</code>, which are available by default, can be used for attributes and text.
                        When creating a new <code>Matcher</code>, one is not forced to implement for both. For each
                        matcher type a specific trait exists. Extend <code>AttributeMatcher</code> or <code>TextMatcher</code> or
                        both, when creating your own <code>Matcher</code>
                    </p>
                    <p>When creating a custom <code>Matcher</code> the most important thing is to provide a detailed
                        <code>Some(Misfit)</code> in case the <code>Matcher</code> doesn't match.
                        In case of a match, the <code>Matcher</code> returns None.
                    </p>
                    <h3 id="api_Login">Login</h3>
                    <p>
                        The Login trait is very simple. It only defines what the <code>username</code> and <code>password</code>
                        field should be called.
                        It is used to mark specific implementations as <code>Login</code> and to assert that <code>username</code>
                        and <code>password</code> are consistent over all implementations. Depending on the
                        authentication process for which a Login trait was implemented, it might make sense to overwrite the <code>login</code> function
                        from <a href="documentation.html#api_IntegrationSpec">IntegrationSpec</a>.
                    </p>
                    <h3 id="api_WebDriver">WebClientExposingDriver</h3>
                    <p>
                        <i>ScalaWebTest</i> per default uses a custom web driver, more precisely a wrapper for the HtmlUnitDriver.
                        Thanks to this wrapper, we can expose the WebClient to enable more control over the WebClient.
                    </p>
                    <h3 id="api_WebDriverConfigFixtures">WebClientExposingDriverConfigFixtures</h3>
                    <p>The WebClientExposingDriverConfigFixtures provide the option to execute a <i>closure</i> with a specific
                        configuration. After the <i>closure</i> is executed, the WebDriver configuration will be
                        reverted to what it was before the call of the fixture.</p>
                </section>
                <div id="topspace"></div>
            </div>
        </div>
    </div>
</div>

<div id="sidebar">
    <div>
        <a href="#header">
            <button id="gttBtn">Go to Top!</button>
        </a>
    </div>

    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#coreFeatures">Core Features</a>
                </header>
                <li class="child"><a href="#handlingWebRequests">Handling of web requests and state</a></li>
                <li class="child"><a href="#gaugesForSimpleTests">Gauges for simple tests</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#gettingStarted">Getting started</a>
                </header>
                <li class="child"><a href="#addSWT">Add ScalaWebTest to your project</a></li>
                <li class="child"><a href="#firsttest">Write your first test</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#structuringYourProject">Structuring your project</a>
                </header>
                <li class="child"><a href="#basetrait">Build your base trait</a></li>
                <li class="child"><a href="#teststyles">Selecting a style</a></li>
                <li class="child"><a href="#config">Configure your tests</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#writingGauges">Writing gauges</a>
                </header>
                <li class="child"><a href="#usingGauges">Using gauges</a></li>
                <li class="child"><a href="#classes">Test for classes on elements</a></li>
                <li class="child"><a href="#singleElements">Test single elements</a></li>
                <li class="child"><a href="#contains">Test for containment</a></li>
                <li class="child"><a href="#regex">Test for regex matches</a></li>
                <li class="child"><a href="#negation">Negating your tests</a></li>
                <li class="child"><a href="#process">Testing a complete process</a></li>
            </ul>
        </ul>
    </section>

    <section>
         <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#lifecycleAndConfiguration">Lifecycle and Configuration</a>
                </header>
                <li class="child"><a href="#lifecycle">Testing lifecycle</a></li>
                <li class="child"><a href="#arguments">Runner arguments</a></li>
                <li class="child"><a href="#envVars">Environment variables</a></li>
                <li class="child"><a href="#systemProperties">System Properties</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#browserDependent">Browser dependent features</a>
                </header>
                <li class="child"><a href="#executingJavascript">Executing JavaScript</a></li>
                <li class="child"><a href="#responseCodeHeaders">Access response code and response headers</a></li>
                <li class="child"><a href="#chrome">Using Chrome</a></li>
                <li class="child"><a href="#otherBrowsers">Other Browsers</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#docker">Running ScalaWebTest in docker</a>
                </header>
                <li><a href="#defaultImage">Using the default image</a></li>
                <li><a href="#ownImage">Building your own image</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#additionalModules">Additional modules</a>
                </header>
                <li class="child"><a href="#modules">Modules</a></li>
                <li class="child"><a href="#modules_aem">AEM module</a></li>
                <li class="child"><a href="#modules_json">JSON module</a></li>
            </ul>
        </ul>
    </section>
    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#extendingScalaWeText">Extending ScalaWebTest</a>
                </header>
                <li class="child"><a href="#extending_matchers">Create a custom matcher</a></li>
                <li class="child"><a href="#extending_login">Create a custom login</a></li>
                <li class="child"><a href="#extending_module">Create your own module</a></li>
            </ul>
        </ul>
    </section>

    <section>
        <ul class="default">
            <ul class="sidebarHeadings">
                <header>
                    <a href="#internalStructure">Internal structure</a>
                </header>
                <li class="child"><a href="#api_IntegrationSpec">IntegrationSpec</a></li>
                <li class="child"><a href="#api_Integration_Spec">Integration*Spec</a></li>
                <li class="child"><a href="#api_SpecBehavior">*SpecBehavior</a></li>
                <li class="child"><a href="#api_Gauge">Gauge</a></li>
                <li class="child"><a href="#api_Misfit">Misfit</a></li>
                <li class="child"><a href="#api_Matchers">Matchers</a></li>
                <li class="child"><a href="#api_Login">Login</a></li>
                <li class="child"><a href="#api_WebDriver">WebDriver</a></li>
                <li class="child"><a href="#api_WebDriverConfigFixtures">WebDriverConfigFixtures</a></li>
            </ul>
        </ul>
    </section>
</div>
<script>
    $(document).ready(function () {

        var docContentView = new ScalaWebTest.DocContentView("#content");
        var sidebar = new ScalaWebTest.Sidebar("#sidebar", docContentView);
        sidebar.init();

    });
</script>
<style>
    #contentNavButtonRight button{
        display: block;
    }
</style>
</body>
</html>
